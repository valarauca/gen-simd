extern crate regex;
use regex::Regex;
#[macro_use]
extern crate lazy_static;
mod crappy_parser;
use crappy_parser::{Intrinsic,populate_intrinsic};
mod llvmint_parser;
use llvmint_parser::{populate_llvmint_x86,populate_llvmint_aarch64,populate_llvmint_arm};
mod joiner;
use joiner::{joiner_x86,joiner_generic};
use std::process::Command;
use std::io::prelude::*;
use std::fs::{read_dir,File,OpenOptions,DirEntry};
use std::path::PathBuf;

//
//Build a platform specific header
//
fn build_output_header(base: &str) -> String {
    format!(r#"// Copyright 2015 The Rust Project Developers. See the COPYRIGHT
// file at the top-level directory of this distribution and at
// http://rust-lang.org/COPYRIGHT.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

// DO NOT EDIT: autogenerated by etc/platform-intrinsics/generator.py
// ignore-tidy-linelength

#![allow(unused_imports)]

use {0}Intrinsic, Type{1};
use IntrinsicDef::Named;

// The default inlining settings trigger a pathological behaviour in
// LLVM, which causes makes compilation very slow. See #28273.
#[inline(never)]
pub fn find(name: &str) -> Option<Intrinsic> {0}
    if !name.starts_with("{2}") {0} return None {1}
    Some(match name {0}"#, "{", "}", base)
}

//
//End of file is generalized
//
const end_of_file: &'static str = "
        _ => return None,
    })
}";

//
//Handle reading and parsing the GNU intrin.h files
//
lazy_static! {
    static ref ISHEADER: Regex = Regex::new(r"[\w]intrin\.h").unwrap();
}
fn is_file(item: DirEntry) -> Option<(PathBuf,usize)> {
    let path = item.path();
    let meta = item
        .metadata()
        .expect("Failed to fetch metadata");
    if meta.is_file() {
        Some((path,meta.len() as usize))
    } else {
        None
    }
}
fn name_correct(item: &(PathBuf,usize)) -> bool {
    ISHEADER.is_match(item.0.to_str().expect("Failed to turn PathBuf to &str"))
}
fn open_file<'a>(item: (PathBuf,usize)) -> Vec<Intrinsic> {
    let (p,s) = item;
    let mut buffer = String::with_capacity(s);
    let mut f: File = OpenOptions::new().write(false).read(true).open(p).expect("Failed to open file");
    f.read_to_string(&mut buffer).expect("Failed to read file");
    populate_intrinsic(&buffer)
}

//
//Define a macro for MIPS/ARM/AARCH64
//
macro_rules! repeative_code {
    ($platform:expr, $output:expr,$symbol:ident, $joiner: expr) => {{
        //open llvmint
        let mut llvmint: File = OpenOptions::new()
            .write(false)
            .read(true)
            .open("llvmint/src/lib.rs")
            .expect("Failed to open llvmint");
        let mut llvmint_buffer = String::with_capacity(2000000);
        llvmint
            .read_to_string(&mut llvmint_buffer)
            .expect("Failed to read llvmint");
        //parse llvmint_buffer
        let mut llvmint_codes = $symbol(&llvmint_buffer);
        llvmint_codes.shrink_to_fit();
        //build output buffer
        let mut output_buffer = String::with_capacity(12000);
        output_buffer.push_str(&build_output_header($platform));
        //read item
        for llvm in llvmint_codes {
            //convert the intrinsic to a string
            let temp = joiner_generic(&llvm, $joiner);
            //join with the output buffer
            output_buffer.push_str(&temp);
            output_buffer.push_str(",");
        }
        output_buffer.push_str(end_of_file);
        //build output file
        let mut output: File = File::create($output).expect("Failed to create output");
        output.write_all(output_buffer.as_bytes()).expect("Failed to write output");
    }}
}

//
//Entry Point
//
fn main() {

    let mut args: Vec<String> = ::std::env::args().skip(1).collect();

    //clone the respective repositories
    if args.len() >= 1 && args[0] == "-fetch" {
        //get GCC
        let _ = Command::new("git")
            .arg("clone")
            .arg("--depth")
            .arg("1")
            .arg("https://github.com/gcc-mirror/gcc")
            .output()
            .expect("Failed to clone https://github.com/gcc-mirror/gcc");

        //get llvmint
        let _ = Command::new("git")
            .arg("clone")
            .arg("--depth")
            .arg("1")
            .arg("https://github.com/huonw/llvmint")
            .output()
            .expect("Failed to clone https://github.com/huonw/llvmint");
        args.remove(0);
    }

    //build x86 definations
    if args.len() >= 1 && args[0] == "-x86" {
        //open llvmint
        let mut llvmint: File = OpenOptions::new()
            .write(false)
            .read(true)
            .open("llvmint/src/lib.rs")
            .expect("Failed to open llvmint");
        let mut llvmint_buffer = String::with_capacity(2000000);
        llvmint
            .read_to_string(&mut llvmint_buffer)
            .expect("Failed to read llvmint");
        //parse llvmint_buffer
        let mut llvmint_codes = populate_llvmint_x86(&llvmint_buffer);
        llvmint_codes.shrink_to_fit();
        //open gcc platform intrinsics
        let iter = read_dir("gcc/gcc/config/i386")
            .expect("Failed to open i386 directory in gcc's git repo");
        //get gnu symbols
        let mut gnu = Vec::<Intrinsic>::with_capacity(3000);
        for i in iter
            .map(|x|x.expect("Failed to transverse file"))
            .filter_map(is_file)
            .filter(name_correct)
            .map(open_file) {
            for item in i {
                gnu.push(item);
            }
        }
        gnu.shrink_to_fit();
        //build output buffer
        let mut output_buffer = String::with_capacity(4000);
        output_buffer.push_str(&build_output_header("x86"));
        //get each header
        for llvmint in llvmint_codes{
            //return all GNU identifiers related to that hash
            let hash = llvmint.gnu_hash;
            for gnu in gnu.iter().filter(|x| x.gnu_hash==hash) {
                let temp = joiner_x86(&llvmint, &gnu);
                output_buffer.push_str(&temp);
                output_buffer.push_str(",");
            }
        }
        output_buffer.push_str(end_of_file);
        //build output file
        let mut output: File = File::create("x86.rs").expect("Failed to create output");
        output.write_all(output_buffer.as_bytes()).expect("Failed to write output");
        args.remove(0);
    }

    //build the aarch64 neon definations
    if args.len() >= 1 && args[0] == "-aarch64" {
        repeative_code!("aarch64", "aarch64.rs", populate_llvmint_aarch64, "aarch64_");
        args.remove(0);
    }

    //build the arm neon definations
    if args.len() >= 1 && args[0] == "-arm" {
        repeative_code!("arm", "arm.rs", populate_llvmint_arm, "arm_");
        args.remove(0);
    }
    
    //clean remove the cloned git repositories
    if args.len() >= 1 && args[0] == "-clean" {
        //remove  GCC
        let _ = Command::new("rm")
            .arg("-rf")
            .arg("gcc/")
            .arg("llvmint/")
            .output()
            .expect("Failed to remove cloned directories");
    }

}
